<!--
IsingCosmos
Copyright 2026 wuchenxiuwu
<https://github.com/wuchenxiuwu>

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program. If not, see <http://www.gnu.org/licenses/>.
-->

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>二维伊辛宇宙模型</title>
    <style>
        * {
            box-sizing: border-box;
            user-select: none;
        }
        body {
            margin: 0;
            background: #0a0f14;
            font-family: 'Segoe UI', Roboto, sans-serif;
            color: #e0eef5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 10px;
        }
        #canvas-container {
            background: #101a22;
            border-radius: 40px;
            padding: 15px;
            box-shadow: 0 15px 30px rgba(0,0,0,0.8);
            border: 1px solid #2f4e60;
            max-width: 100%;
            width: fit-content;
        }
        canvas {
            display: block;
            width: min(80vw, 80vh);
            height: min(80vw, 80vh);
            border-radius: 28px;
            background: #0d1a24;
        }
        #control-panel {
            margin-top: 16px;
            background: #14232e;
            border-radius: 36px;
            padding: 16px 20px;
            border: 1px solid #2b5b70;
            box-shadow: 0 10px 20px black;
            width: 100%;
            max-width: 700px;
        }
        .param-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        .param-label {
            width: 70px;
            color: #b0d5e8;
            font-weight: 600;
        }
        .sensor-value {
            background: #1f3845;
            padding: 2px 10px;
            border-radius: 20px;
            font-family: monospace;
            min-width: 60px;
            text-align: center;
        }
        select {
            background: #1e3f50;
            color: white;
            border: 1px solid #3799b8;
            border-radius: 30px;
            padding: 6px 15px;
            font-size: 0.9rem;
        }
        button {
            background: #285f75;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 40px;
            font-weight: bold;
            margin: 5px 5px 0 0;
            border: 1px solid #4fb0d0;
            cursor: pointer;
        }
        .stat-row {
            display: flex;
            gap: 15px;
            margin: 12px 0 5px;
            flex-wrap: wrap;
        }
        .stat-item {
            background: #1f3642;
            border-radius: 30px;
            padding: 6px 16px;
            font-size: 0.9rem;
        }
        #status {
            color: #ffd966;
        }
        .footer {
            font-size: 0.8rem;
            color: #5b8fa0;
            margin-top: 12px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="universeCanvas" width="600" height="600"></canvas>
    </div>

    <div id="control-panel">
        <div class="param-row">
            <span class="param-label">温度 T</span>
            <select id="bindT">
                <option value="none">固定 2.5</option>
                <option value="light">环境光</option>
                <option value="accMagnitude">加速度模</option>
                <option value="gyroMagnitude">陀螺仪模</option>
            </select>
            <span class="sensor-value" id="rawT">—</span>
            <span>→ <span id="mappedT">2.50</span></span>
        </div>
        <div class="param-row">
            <span class="param-label">外场 H</span>
            <select id="bindH">
                <option value="none">固定 0.0</option>
                <option value="accX">加速度 X</option>
                <option value="accY">加速度 Y</option>
                <option value="magX">磁场 X</option>
            </select>
            <span class="sensor-value" id="rawH">—</span>
            <span>→ <span id="mappedH">0.00</span></span>
        </div>
        <div class="param-row">
            <span class="param-label">耦合 J</span>
            <select id="bindJ">
                <option value="none">固定 1.0</option>
                <option value="light">环境光</option>
                <option value="proximity">接近</option>
            </select>
            <span class="sensor-value" id="rawJ">—</span>
            <span>→ <span id="mappedJ">1.00</span></span>
        </div>

        <div class="stat-row">
            <div class="stat-item">加速度模: <span id="accMagnitude">0.0</span> m/s²</div>
            <div class="stat-item">暗物质 ⟨|φ|²⟩: <span id="dmDensity">0.0</span></div>
            <div class="stat-item">天体数: <span id="bodyCount">0</span></div>
            <div class="stat-item">黑洞总质量: <span id="bhMass">0.0</span></div>
        </div>

        <div style="display: flex; gap: 10px; flex-wrap: wrap; margin-top: 8px;">
            <button id="resetBtn">随机重置</button>
            <button id="pauseBtn">暂停</button>
            <button id="addStarBtn">添加恒星</button>
            <button id="addBlackHoleBtn">添加黑洞</button>
            <button id="addPlanetBtn">添加行星</button>
            <button id="addAsteroidBtn"> 添加小行星</button>
        </div>

        <div class="footer">
            <span id="status">传感器初始化中...</span>  |  白色↑ 黑色↓  ·  黄:恒星 黑:黑洞 绿:行星 棕:小行星  ·  蓝点:暗物质密度
        </div>
    </div>

    <script>
        // ==================== 工具 & 常量 ====================
        const L = 24;                              // 网格 24x24
        const N = L * L;
        const GRAV = 0.8;
        const DM_COUPLING = 0.5;
        const DE_COUPLING = 0.2;
        const DT = 0.02;
        const SUBSTEPS = 4;
        const DM_MASS = 0.5;
        const DM_LAMBDA = 0.2;
        const DM_DIFFUSION = 0.3;
        const DM_NOISE = 0.2;
        const HAWKING_ALPHA = 0.002;
        const MIN_BH_MASS = 0.8;
        const MAX_BODIES = 1024;

        function idx(i, j) {
            i = (i + L) % L;
            j = (j + L) % L;
            return i * L + j;
        }

        // ==================== 传感器融合 ====================
        class SensorFusion {
            constructor() {
                this.acc = { x:0, y:0, z:0 };
                this.gyro = { x:0, y:0, z:0 };
                this.mag = { x:0, y:0, z:0 };
                this.light = 100;
                this.prox = 5;
                this.accMagnitude = 0;
                this.initSensors();
            }
            initSensors() {
                if ('Accelerometer' in window) {
                    try {
                        const acc = new Accelerometer({ frequency: 30 });
                        acc.addEventListener('reading', () => {
                            this.acc = { x: acc.x, y: acc.y, z: acc.z };
                            this.updateAccMagnitude();
                        });
                        acc.start();
                    } catch(e) { console.warn('加速度计失败'); }
                }
                if ('Gyroscope' in window) {
                    try {
                        const gyro = new Gyroscope({ frequency: 30 });
                        gyro.addEventListener('reading', () => {
                            this.gyro = { x: gyro.x, y: gyro.y, z: gyro.z };
                        });
                        gyro.start();
                    } catch(e) { console.warn('陀螺仪失败'); }
                }
                if ('Magnetometer' in window) {
                    try {
                        const mag = new Magnetometer({ frequency: 15 });
                        mag.addEventListener('reading', () => {
                            this.mag = { x: mag.x, y: mag.y, z: mag.z };
                        });
                        mag.start();
                    } catch(e) { console.warn('磁力计失败'); }
                }
                if ('AmbientLightSensor' in window) {
                    try {
                        const light = new AmbientLightSensor();
                        light.addEventListener('reading', () => {
                            this.light = light.illuminance;
                        });
                        light.start();
                    } catch(e) { console.warn('环境光不可用'); }
                }
                if ('ProximitySensor' in window) {
                    try {
                        const prox = new ProximitySensor();
                        prox.addEventListener('reading', () => {
                            this.prox = prox.distance;
                        });
                        prox.start();
                    } catch(e) { console.warn('接近传感器不可用'); }
                }
                document.getElementById('status').innerText = '传感器已激活';
            }
            updateAccMagnitude() {
                this.accMagnitude = Math.sqrt(this.acc.x**2 + this.acc.y**2 + this.acc.z**2);
            }
            getValue(sensorName) {
                switch(sensorName) {
                    case 'light': return this.light;
                    case 'proximity': return this.prox;
                    case 'accX': return this.acc.x;
                    case 'accY': return this.acc.y;
                    case 'accZ': return this.acc.z;
                    case 'gyroX': return this.gyro.x;
                    case 'gyroY': return this.gyro.y;
                    case 'gyroZ': return this.gyro.z;
                    case 'magX': return this.mag.x;
                    case 'magY': return this.mag.y;
                    case 'magZ': return this.mag.z;
                    case 'accMagnitude': return this.accMagnitude;
                    case 'gyroMagnitude': return Math.sqrt(this.gyro.x**2 + this.gyro.y**2 + this.gyro.z**2);
                    default: return 0;
                }
            }
        }

        // ==================== 天体类 ====================
        class Body {
            constructor(x, y, vx, vy, mass, type) {
                this.x = x; this.y = y;
                this.vx = vx || 0; this.vy = vy || 0;
                this.mass = mass;
                this.type = type; // 'star', 'blackhole', 'planet', 'asteroid'
                this.luminosity = (type === 'star') ? mass * 2 : 0;
                this.eventHorizon = (type === 'blackhole') ? mass * 0.8 : 0;
                this.hawkingTemp = (type === 'blackhole') ? 0.5 / (mass + 0.1) : 0;
            }

            updateBlackhole() {
                this.eventHorizon = this.mass * 0.8;
                this.hawkingTemp = 0.5 / (this.mass + 0.1);
            }

            hawkingRadiation(dt) {
                if (this.type !== 'blackhole') return 0;
                const dm = -HAWKING_ALPHA * dt / (this.mass * this.mass + 0.01);
                const newMass = Math.max(MIN_BH_MASS, this.mass + dm);
                const actualDm = newMass - this.mass;
                this.mass = newMass;
                if (this.mass <= MIN_BH_MASS + 0.01) {
                    return actualDm;
                }
                this.updateBlackhole();
                return actualDm;
            }

            inHorizon(i, j) {
                if (this.type !== 'blackhole') return false;
                const dx = i - this.x;
                const dy = j - this.y;
                const r = Math.sqrt(dx*dx + dy*dy);
                return r < this.eventHorizon;
            }

            swallows(other) {
                if (this.type !== 'blackhole') return false;
                if (other.type === 'blackhole') return false;
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const r = Math.sqrt(dx*dx + dy*dy);
                return r < this.eventHorizon;
            }

            potential(i, j) {
                const dx = i - this.x;
                const dy = j - this.y;
                const r = Math.sqrt(dx*dx + dy*dy) + 0.1;
                return -GRAV * this.mass / r;
            }

            temperatureBoost(i, j) {
                const dx = i - this.x;
                const dy = j - this.y;
                const r = Math.sqrt(dx*dx + dy*dy) + 0.1;
                if (this.type === 'star') {
                    return this.luminosity / r;
                } else if (this.type === 'blackhole') {
                    return this.hawkingTemp * 2 / r;
                }
                return 0;
            }
        }

        // ==================== 宇宙模型 ====================
        class Universe {
            constructor(L) {
                this.L = L;
                this.N = L*L;

                this.spins = new Int8Array(this.N);
                this.nextSpins = new Int8Array(this.N);
                for (let i=0; i<this.N; i++) {
                    this.spins[i] = Math.random() < 0.5 ? 1 : -1;
                }
                this.nextSpins.set(this.spins);

                this.dmRe = new Float32Array(this.N);
                this.dmIm = new Float32Array(this.N);
                for (let i=0; i<this.N; i++) {
                    const amp = 0.2 + Math.random() * 0.3;
                    const phase = Math.random() * 2*Math.PI;
                    this.dmRe[i] = amp * Math.cos(phase);
                    this.dmIm[i] = amp * Math.sin(phase);
                }

                this.vacuum = new Float32Array(this.N);
                for (let i=0; i<this.N; i++) {
                    this.vacuum[i] = 0.5 + Math.random() * 0.5;
                }

                this.bodies = [];
                this.bodies.push(new Body(L/2-1, L/2-1, 0, 0, 7, 'star'));
                this.bodies.push(new Body(L/2+2, L/2+2, -0.2, 0.1, 6, 'blackhole'));
                this.bodies.push(new Body(L/2-2, L/2+1, 1.2, 0.5, 1.5, 'planet'));
                this.bodies.push(new Body(L/2+1, L/2-2, -0.8, -0.8, 0.9, 'planet'));
                for (let k=0; k<6; k++) {
                    let angle = Math.random() * 2*Math.PI;
                    let r = 5 + Math.random()*4;
                    let x = L/2 + r*Math.cos(angle);
                    let y = L/2 + r*Math.sin(angle);
                    let v = Math.sqrt(GRAV * 7 / r) * 0.9;
                    let vx = -v * Math.sin(angle) * (1 + 0.2*Math.random());
                    let vy = v * Math.cos(angle) * (1 + 0.2*Math.random());
                    this.bodies.push(new Body(x, y, vx, vy, 0.2+Math.random()*0.4, 'asteroid'));
                }

                this.horizonMask = new Array(this.N).fill(false);
                this.updateHorizonMask();

                this.T = 2.5;
                this.H = 0.0;
                this.J = 1.0;
                this.bindings = { T: null, H: null, J: null };
            }

            updateHorizonMask() {
                this.horizonMask.fill(false);
                for (let b of this.bodies) {
                    if (b.type === 'blackhole') {
                        for (let i=0; i<this.L; i++) {
                            for (let j=0; j<this.L; j++) {
                                if (b.inHorizon(i, j)) {
                                    this.horizonMask[idx(i,j)] = true;
                                }
                            }
                        }
                    }
                }
            }

            setBinding(param, sensor, minOut, maxOut, minIn, maxIn) {
                this.bindings[param] = { sensor, minOut, maxOut, minIn, maxIn };
            }

            updateParams(sensors) {
                for (let param of ['T','H','J']) {
                    const b = this.bindings[param];
                    if (!b || b.sensor === 'none') continue;
                    let raw = sensors.getValue(b.sensor);
                    if (raw === undefined) raw = 0;
                    let clamped = Math.min(b.maxIn, Math.max(b.minIn, raw));
                    let mapped = b.minOut + (b.maxOut - b.minOut) * (clamped - b.minIn) / (b.maxIn - b.minIn);
                    this[param] = mapped;
                    document.getElementById(`raw${param}`).innerText = raw.toFixed(2);
                    document.getElementById(`mapped${param}`).innerText = this[param].toFixed(2);
                }
            }

            localField(i, j) {
                const idx0 = i*this.L + j;
                let field = 0;

                const neighbors = [[i-1,j],[i+1,j],[i,j-1],[i,j+1]];
                for (let [ni,nj] of neighbors) {
                    ni = (ni+this.L)%this.L;
                    nj = (nj+this.L)%this.L;
                    const nIdx = ni*this.L + nj;
                    const modJ = this.J * (1 - DE_COUPLING * (this.vacuum[idx0] + this.vacuum[nIdx]) / 2);
                    field += modJ * this.spins[nIdx];
                }

                field += this.H;

                const dmDensity = this.dmRe[idx0]**2 + this.dmIm[idx0]**2;
                field += DM_COUPLING * dmDensity;

                for (let b of this.bodies) {
                    field += b.potential(i, j);
                }

                return field;
            }

            dmPotentialDerivative(re, im, spinAvg) {
                const r2 = re*re + im*im;
                const factor = DM_MASS + DM_LAMBDA * r2 - 2.0 * spinAvg;
                return { re: factor * re, im: factor * im };
            }

            evolveDarkMatter(dt, spinAvgGrid) {
                const N = this.N;
                const k1Re = new Float32Array(N);
                const k1Im = new Float32Array(N);
                const k2Re = new Float32Array(N);
                const k2Im = new Float32Array(N);
                const k3Re = new Float32Array(N);
                const k3Im = new Float32Array(N);
                const k4Re = new Float32Array(N);
                const k4Im = new Float32Array(N);

                const computeRHS = (re, im, targetRe, targetIm) => {
                    for (let i=0; i<this.L; i++) {
                        for (let j=0; j<this.L; j++) {
                            const idx0 = i*this.L + j;
                            let lapRe = 0, lapIm = 0;
                            const neighbors = [[i-1,j],[i+1,j],[i,j-1],[i,j+1]];
                            for (let [ni,nj] of neighbors) {
                                ni = (ni+this.L)%this.L;
                                nj = (nj+this.L)%this.L;
                                const nIdx = ni*this.L + nj;
                                lapRe += re[nIdx] - re[idx0];
                                lapIm += im[nIdx] - im[idx0];
                            }
                            lapRe *= DM_DIFFUSION;
                            lapIm *= DM_DIFFUSION;

                            const spinAvg = spinAvgGrid ? spinAvgGrid[idx0] : 0;
                            const {re: dvRe, im: dvIm} = this.dmPotentialDerivative(re[idx0], im[idx0], spinAvg);

                            const noiseRe = DM_NOISE * Math.sqrt(dt) * (Math.random()*2-1);
                            const noiseIm = DM_NOISE * Math.sqrt(dt) * (Math.random()*2-1);

                            targetRe[idx0] = lapRe - dvRe + noiseRe;
                            targetIm[idx0] = lapIm - dvIm + noiseIm;
                        }
                    }
                };

                computeRHS(this.dmRe, this.dmIm, k1Re, k1Im);

                const tmpRe = new Float32Array(N);
                const tmpIm = new Float32Array(N);
                for (let i=0; i<N; i++) {
                    tmpRe[i] = this.dmRe[i] + 0.5*dt*k1Re[i];
                    tmpIm[i] = this.dmIm[i] + 0.5*dt*k1Im[i];
                }
                computeRHS(tmpRe, tmpIm, k2Re, k2Im);

                for (let i=0; i<N; i++) {
                    tmpRe[i] = this.dmRe[i] + 0.5*dt*k2Re[i];
                    tmpIm[i] = this.dmIm[i] + 0.5*dt*k2Im[i];
                }
                computeRHS(tmpRe, tmpIm, k3Re, k3Im);

                for (let i=0; i<N; i++) {
                    tmpRe[i] = this.dmRe[i] + dt*k3Re[i];
                    tmpIm[i] = this.dmIm[i] + dt*k3Im[i];
                }
                computeRHS(tmpRe, tmpIm, k4Re, k4Im);

                for (let i=0; i<N; i++) {
                    this.dmRe[i] += dt/6 * (k1Re[i] + 2*k2Re[i] + 2*k3Re[i] + k4Re[i]);
                    this.dmIm[i] += dt/6 * (k1Im[i] + 2*k2Im[i] + 2*k3Im[i] + k4Im[i]);
                }
            }

            computeAccJerk() {
                const n = this.bodies.length;
                const acc = new Array(n);
                const jerk = new Array(n);
                for (let i=0; i<n; i++) {
                    let ax=0, ay=0, jx=0, jy=0;
                    const bi = this.bodies[i];
                    for (let j=0; j<n; j++) {
                        if (i===j) continue;
                        const bj = this.bodies[j];
                        const dx = bj.x - bi.x;
                        const dy = bj.y - bi.y;
                        const r2 = dx*dx + dy*dy + 0.01;
                        const r = Math.sqrt(r2);
                        const r3 = r2 * r;
                        const dvx = bj.vx - bi.vx;
                        const dvy = bj.vy - bi.vy;
                        const rdotv = (dx*dvx + dy*dvy) / r;

                        const a_mag = GRAV * bj.mass / r3;
                        ax += a_mag * dx;
                        ay += a_mag * dy;
                        jx += a_mag * (dvx - 3 * rdotv * dx / r);
                        jy += a_mag * (dvy - 3 * rdotv * dy / r);
                    }
                    acc[i] = {ax, ay};
                    jerk[i] = {jx, jy};
                }
                return {acc, jerk};
            }

            evolveBodies(dt) {
                const n = this.bodies.length;
                if (n === 0) return;

                const {acc, jerk} = this.computeAccJerk();

                const predPos = [];
                const predVel = [];
                for (let i=0; i<n; i++) {
                    const b = this.bodies[i];
                    predPos.push({
                        x: b.x + b.vx*dt + 0.5*acc[i].ax*dt*dt + (1/6)*jerk[i].jx*dt*dt*dt,
                        y: b.y + b.vy*dt + 0.5*acc[i].ay*dt*dt + (1/6)*jerk[i].jy*dt*dt*dt
                    });
                    predVel.push({
                        vx: b.vx + acc[i].ax*dt + 0.5*jerk[i].jx*dt*dt,
                        vy: b.vy + acc[i].ay*dt + 0.5*jerk[i].jy*dt*dt
                    });
                }

                const acc1 = [], jerk1 = [];
                for (let i=0; i<n; i++) {
                    let ax=0, ay=0, jx=0, jy=0;
                    const bi = this.bodies[i];
                    for (let j=0; j<n; j++) {
                        if (i===j) continue;
                        const bj = this.bodies[j];
                        const dx = predPos[j].x - predPos[i].x;
                        const dy = predPos[j].y - predPos[i].y;
                        const r2 = dx*dx + dy*dy + 0.01;
                        const r = Math.sqrt(r2);
                        const r3 = r2 * r;
                        const dvx = predVel[j].vx - predVel[i].vx;
                        const dvy = predVel[j].vy - predVel[i].vy;
                        const rdotv = (dx*dvx + dy*dvy) / r;

                        const a_mag = GRAV * bj.mass / r3;
                        ax += a_mag * dx;
                        ay += a_mag * dy;
                        jx += a_mag * (dvx - 3 * rdotv * dx / r);
                        jy += a_mag * (dvy - 3 * rdotv * dy / r);
                    }
                    acc1.push({ax, ay});
                    jerk1.push({jx, jy});
                }

                for (let i=0; i<n; i++) {
                    const b = this.bodies[i];
                    const a0 = acc[i], j0 = jerk[i];
                    const a1 = acc1[i], j1 = jerk1[i];

                    const corrPosX = (dt*dt/12) * (j1.jx - j0.jx);
                    const corrPosY = (dt*dt/12) * (j1.jy - j0.jy);
                    const corrVelX = (dt/2) * (a1.ax + a0.ax) + (dt*dt/12) * (j1.jx - j0.jx);
                    const corrVelY = (dt/2) * (a1.ay + a0.ay) + (dt*dt/12) * (j1.jy - j0.jy);

                    b.x = predPos[i].x + corrPosX;
                    b.y = predPos[i].y + corrPosY;
                    b.vx = predVel[i].vx + corrVelX;
                    b.vy = predVel[i].vy + corrVelY;

                    if (b.x < 0) b.x += this.L;
                    if (b.x >= this.L) b.x -= this.L;
                    if (b.y < 0) b.y += this.L;
                    if (b.y >= this.L) b.y -= this.L;
                }
            }

            checkBlackholeSwallows() {
                const toRemove = new Set();
                for (let i=0; i<this.bodies.length; i++) {
                    const b = this.bodies[i];
                    if (b.type !== 'blackhole') continue;

                    for (let j=0; j<this.bodies.length; j++) {
                        if (i === j) continue;
                        const other = this.bodies[j];
                        if (other.type === 'blackhole') continue;

                        if (b.swallows(other)) {
                            b.mass += other.mass;
                            b.updateBlackhole();

                            const cx = other.x, cy = other.y;
                            for (let i0=0; i0<this.L; i0++) {
                                for (let j0=0; j0<this.L; j0++) {
                                    const dx = i0 - cx, dy = j0 - cy;
                                    if (dx*dx + dy*dy < 4) {
                                        this.spins[i0*this.L+j0] *= -1;
                                    }
                                }
                            }

                            const releaseRadius = 3;
                            for (let di=-releaseRadius; di<=releaseRadius; di++) {
                                for (let dj=-releaseRadius; dj<=releaseRadius; dj++) {
                                    const ni = Math.round(cx + di);
                                    const nj = Math.round(cy + dj);
                                    if (ni>=0 && ni<this.L && nj>=0 && nj<this.L) {
                                        const dist = Math.sqrt(di*di + dj*dj);
                                        if (dist <= releaseRadius) {
                                            const idxRel = ni*this.L + nj;
                                            const boost = 1.0 * (1 - dist/releaseRadius);
                                            this.dmRe[idxRel] *= (1 + boost);
                                            this.dmIm[idxRel] *= (1 + boost);
                                            const amp = Math.sqrt(this.dmRe[idxRel]**2 + this.dmIm[idxRel]**2);
                                            if (amp > 3.0) {
                                                const scale = 3.0 / amp;
                                                this.dmRe[idxRel] *= scale;
                                                this.dmIm[idxRel] *= scale;
                                            }
                                        }
                                    }
                                }
                            }

                            toRemove.add(j);
                        }
                    }
                }

                if (toRemove.size > 0) {
                    const indices = Array.from(toRemove).sort((a,b)=>b-a);
                    for (let idx of indices) {
                        this.bodies.splice(idx, 1);
                    }
                    this.updateHorizonMask();
                }
            }

            subStep(dt) {
                const spinAvg = new Float32Array(this.N);
                for (let i=0; i<this.L; i++) {
                    for (let j=0; j<this.L; j++) {
                        let sum = 0, cnt = 0;
                        for (let di=-1; di<=1; di++) {
                            for (let dj=-1; dj<=1; dj++) {
                                const ni = (i+di+this.L)%this.L;
                                const nj = (j+dj+this.L)%this.L;
                                sum += this.spins[ni*this.L+nj];
                                cnt++;
                            }
                        }
                        spinAvg[i*this.L+j] = sum / cnt;
                    }
                }

                this.evolveDarkMatter(dt, spinAvg);

                for (let i=0; i<this.L; i++) {
                    for (let j=0; j<this.L; j++) {
                        const idx0 = i*this.L + j;
                        if (this.horizonMask[idx0]) {
                            this.nextSpins[idx0] = this.spins[idx0];
                            continue;
                        }
                        const s = this.spins[idx0];
                        const field = this.localField(i, j);

                        let tempBoost = 0;
                        for (let b of this.bodies) {
                            tempBoost += b.temperatureBoost(i, j);
                        }
                        const effectiveT = this.T + tempBoost;

                        const dE = 2 * s * field;
                        if (dE <= 0) {
                            this.nextSpins[idx0] = -s;
                        } else {
                            if (Math.random() < Math.exp(-dE / effectiveT)) {
                                this.nextSpins[idx0] = -s;
                            } else {
                                this.nextSpins[idx0] = s;
                            }
                        }
                    }
                }
                [this.spins, this.nextSpins] = [this.nextSpins, this.spins];

                this.evolveBodies(dt);

                const toRemove = [];
                for (let i=0; i<this.bodies.length; i++) {
                    const b = this.bodies[i];
                    if (b.type === 'blackhole') {
                        b.hawkingRadiation(dt);
                        if (b.mass <= MIN_BH_MASS + 0.02) {
                            const cx = b.x, cy = b.y;
                            for (let i0=0; i0<this.L; i0++) {
                                for (let j0=0; j0<this.L; j0++) {
                                    const dx = i0 - cx, dy = j0 - cy;
                                    if (dx*dx + dy*dy < 9) {
                                        this.spins[i0*this.L+j0] *= -1;
                                    }
                                }
                            }
                            toRemove.push(i);
                        } else {
                            b.updateBlackhole();
                        }
                    }
                }
                for (let i=toRemove.length-1; i>=0; i--) {
                    this.bodies.splice(toRemove[i], 1);
                }

                this.checkBlackholeSwallows();
                this.updateHorizonMask();
            }

            step() {
                for (let s=0; s<SUBSTEPS; s++) {
                    this.subStep(DT);
                }
            }

            randomReset() {
                for (let i=0; i<this.N; i++) {
                    this.spins[i] = Math.random() < 0.5 ? 1 : -1;
                }
                this.nextSpins.set(this.spins);
            }

            addBody(type) {
                let x = Math.random() * this.L;
                let y = Math.random() * this.L;
                if (type === 'star') {
                    this.bodies.push(new Body(x, y, 0, 0, 5+Math.random()*3, 'star'));
                } else if (type === 'blackhole') {
                    this.bodies.push(new Body(x, y, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, 7+Math.random()*3, 'blackhole'));
                } else if (type === 'planet') {
                    const center = this.bodies.find(b => b.type==='star') || {x:this.L/2, y:this.L/2};
                    const dx = x - center.x;
                    const dy = y - center.y;
                    const r = Math.sqrt(dx*dx+dy*dy) + 0.1;
                    const v = Math.sqrt(GRAV * 5 / r) * 0.9;
                    const angle = Math.atan2(dy, dx) + Math.PI/2;
                    const vx = v * Math.cos(angle);
                    const vy = v * Math.sin(angle);
                    this.bodies.push(new Body(x, y, vx, vy, 0.8+Math.random()*0.7, 'planet'));
                } else if (type === 'asteroid') {
                    this.bodies.push(new Body(x, y, (Math.random()-0.5)*2, (Math.random()-0.5)*2, 0.2+Math.random()*0.3, 'asteroid'));
                }
            }

            dmDensityAvg() {
                let sum = 0;
                for (let i=0; i<this.N; i++) sum += this.dmRe[i]**2 + this.dmIm[i]**2;
                return (sum / this.N).toFixed(3);
            }
            bodyCount() { return this.bodies.length; }
            bhMass() {
                const totalMass = this.bodies
                    .filter(b => b.type === 'blackhole')
                    .reduce((sum, b) => sum + b.mass, 0);
                return totalMass.toFixed(2);
            }
        }

        // ==================== WebGL渲染引擎====================
        const canvas = document.getElementById('universeCanvas');
        // 直接请求 WebGL 2.0 上下文
        const gl = canvas.getContext('webgl2');
        if (!gl) {
            alert('您的浏览器不支持 WebGL 2.0，无法显示。');
            throw new Error('WebGL 2.0 not supported');
        }
        console.log('WebGL 2.0 已激活，支持原生实例化');

        // 编译着色器辅助函数
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // 网格着色器（已升级到 GLSL 300 es）
        const gridVS = `#version 300 es
            in vec2 a_position;
            in float a_spin;
            uniform float u_cellSize;
            out float v_spin;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                gl_PointSize = u_cellSize - 1.0;
                v_spin = a_spin;
            }
        `;
        const gridFS = `#version 300 es
            precision highp float;
            in float v_spin;
            out vec4 outColor;
            void main() {
                if (v_spin > 0.0)
                    outColor = vec4(1.0);
                else
                    outColor = vec4(0.1, 0.16, 0.2, 1.0);
            }
        `;

        // 暗物质光晕着色器
        const dmVS = `#version 300 es
            in vec2 a_position;
            in float a_amp;
            in float a_phase;
            uniform float u_cellSize;
            out float v_amp;
            out float v_phase;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                gl_PointSize = u_cellSize * clamp(a_amp * 1.5, 0.5, 3.0);
                v_amp = a_amp;
                v_phase = a_phase;
            }
        `;
        const dmFS = `#version 300 es
            precision highp float;
            in float v_amp;
            in float v_phase;
            out vec4 outColor;
            void main() {
                vec2 c = gl_PointCoord - 0.5;
                float r = length(c) * 2.0;
                if (r > 1.0) discard;
                float alpha = (1.0 - r) * clamp(v_amp * 0.8, 0.0, 0.8);
                vec3 color = vec3(0.4, 0.8, 1.0) * (0.8 + 0.4 * sin(v_phase * 10.0));
                outColor = vec4(color, alpha);
            }
        `;

        // 天体着色器
        const bodyVS = `#version 300 es
            in vec2 a_position; 
            in float a_mass;
            in float a_type;
            uniform float u_cellSize;
            out float v_type;
            out float v_mass;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
                float baseSize = u_cellSize * 0.5;
                if (a_type < 0.5) baseSize = u_cellSize * 0.7;      // 恒星
                else if (a_type < 1.5) baseSize = u_cellSize * 1.0; // 黑洞
                else if (a_type < 2.5) baseSize = u_cellSize * 0.5; // 行星
                else baseSize = u_cellSize * 0.3;                    // 小行星
                gl_PointSize = baseSize * a_mass * 0.5;
                v_type = a_type;
                v_mass = a_mass;
            }
        `;
        const bodyFS = `#version 300 es
            precision highp float;
            in float v_type;
            in float v_mass;
            out vec4 outColor;
            void main() {
                vec2 c = gl_PointCoord - 0.5;
                float r = length(c) * 2.0;
                if (r > 1.0) discard;
                float alpha = 1.0 - smoothstep(0.8, 1.0, r);
                vec3 color;
                if (v_type < 0.5) color = vec3(1.0, 0.67, 0.2);      // 恒星黄
                else if (v_type < 1.5) {
                    color = vec3(0.8, 0.2, 0.2) * (0.5 + 0.5 * (1.0 - r));
                    alpha = 0.9;
                } else if (v_type < 2.5) color = vec3(0.27, 0.67, 0.53); // 行星绿
                else color = vec3(0.53, 0.4, 0.27);                     // 小行星棕
                outColor = vec4(color, alpha);
            }
        `;

        // 创建程序
        function createProgram(gl, vsSource, fsSource) {
            const vs = compileShader(gl, vsSource, gl.VERTEX_SHADER);
            const fs = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);
            const prog = gl.createProgram();
            gl.attachShader(prog, vs);
            gl.attachShader(prog, fs);
            gl.linkProgram(prog);
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(prog));
                return null;
            }
            return prog;
        }

        const gridProg = createProgram(gl, gridVS, gridFS);
        const dmProg = createProgram(gl, dmVS, dmFS);
        const bodyProg = createProgram(gl, bodyVS, bodyFS);

        // 获取 uniform 位置
        const gridUniforms = {
            u_cellSize: gl.getUniformLocation(gridProg, 'u_cellSize')
        };
        const dmUniforms = {
            u_cellSize: gl.getUniformLocation(dmProg, 'u_cellSize')
        };
        const bodyUniforms = {
            u_cellSize: gl.getUniformLocation(bodyProg, 'u_cellSize')
        };

        // 预计算网格顶点位置 (NDC)
        const gridPositions = new Float32Array(N * 2);
        for (let i = 0; i < L; i++) {
            for (let j = 0; j < L; j++) {
                const x = (j + 0.5) / L * 2 - 1;
                const y = 1 - (i + 0.5) / L * 2;
                gridPositions[(i*L + j)*2] = x;
                gridPositions[(i*L + j)*2+1] = y;
            }
        }

        // 网格顶点缓冲区（静态）
        const gridPosBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, gridPosBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, gridPositions, gl.STATIC_DRAW);

        // 网格自旋缓冲区（动态，每帧更新）
        const gridSpinBuffer = gl.createBuffer();

        // 暗物质属性缓冲区（振幅+相位，动态）
        const dmAttrBuffer = gl.createBuffer();
        const dmAttrs = new Float32Array(N * 2);

        const dummyVertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, dummyVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0]), gl.STATIC_DRAW);

        const bodyPosBuffer = gl.createBuffer();
        const bodyMassBuffer = gl.createBuffer();
        const bodyTypeBuffer = gl.createBuffer();

        gl.bindBuffer(gl.ARRAY_BUFFER, bodyPosBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, MAX_BODIES * 2 * 4, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, bodyMassBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, MAX_BODIES * 4, gl.DYNAMIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, bodyTypeBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, MAX_BODIES * 4, gl.DYNAMIC_DRAW);

        // 启用混合
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.clearColor(0.05, 0.1, 0.14, 1.0);

        function updateBodyBuffers() {
            const count = universe.bodies.length;
            if (count === 0) return;

            const posData = new Float32Array(count * 2);
            const massData = new Float32Array(count);
            const typeData = new Float32Array(count);

            for (let i = 0; i < count; i++) {
                const b = universe.bodies[i];
                const x = b.x / L * 2 - 1;
                const y = 1 - b.y / L * 2;
                posData[i*2] = x;
                posData[i*2+1] = y;
                massData[i] = b.mass;
                // 类型编码
                if (b.type === 'star') typeData[i] = 0;
                else if (b.type === 'blackhole') typeData[i] = 1;
                else if (b.type === 'planet') typeData[i] = 2;
                else typeData[i] = 3;
            }

            gl.bindBuffer(gl.ARRAY_BUFFER, bodyPosBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, posData);
            gl.bindBuffer(gl.ARRAY_BUFFER, bodyMassBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, massData);
            gl.bindBuffer(gl.ARRAY_BUFFER, bodyTypeBuffer);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, typeData);
        }

        function drawGrid() {
            gl.useProgram(gridProg);
            gl.uniform1f(gridUniforms.u_cellSize, canvas.width / L);

            gl.bindBuffer(gl.ARRAY_BUFFER, gridPosBuffer);
            const posLoc = gl.getAttribLocation(gridProg, 'a_position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            const spinData = new Float32Array(N);
            for (let i = 0; i < N; i++) spinData[i] = universe.spins[i];
            gl.bindBuffer(gl.ARRAY_BUFFER, gridSpinBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, spinData, gl.DYNAMIC_DRAW);
            const spinLoc = gl.getAttribLocation(gridProg, 'a_spin');
            gl.enableVertexAttribArray(spinLoc);
            gl.vertexAttribPointer(spinLoc, 1, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.POINTS, 0, N);
        }

        function drawDarkMatter() {
            gl.useProgram(dmProg);
            gl.uniform1f(dmUniforms.u_cellSize, canvas.width / L);

            gl.bindBuffer(gl.ARRAY_BUFFER, gridPosBuffer);
            const posLoc = gl.getAttribLocation(dmProg, 'a_position');
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            for (let i = 0; i < N; i++) {
                const amp = Math.sqrt(universe.dmRe[i]**2 + universe.dmIm[i]**2);
                const phase = Math.atan2(universe.dmIm[i], universe.dmRe[i]);
                dmAttrs[i*2] = amp;
                dmAttrs[i*2+1] = phase;
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, dmAttrBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, dmAttrs, gl.DYNAMIC_DRAW);
            const ampLoc = gl.getAttribLocation(dmProg, 'a_amp');
            const phaseLoc = gl.getAttribLocation(dmProg, 'a_phase');
            gl.enableVertexAttribArray(ampLoc);
            gl.enableVertexAttribArray(phaseLoc);
            gl.vertexAttribPointer(ampLoc, 1, gl.FLOAT, false, 8, 0);
            gl.vertexAttribPointer(phaseLoc, 1, gl.FLOAT, false, 8, 4);

            gl.drawArrays(gl.POINTS, 0, N);
        }

        function drawBodies() {
            const count = universe.bodies.length;
            if (count === 0) return;

            gl.useProgram(bodyProg);
            gl.uniform1f(bodyUniforms.u_cellSize, canvas.width / L);

            // 更新实例数据
            updateBodyBuffers();

            // 绑定虚拟顶点（占位，不贡献数据）
            gl.bindBuffer(gl.ARRAY_BUFFER, dummyVertexBuffer);
            const dummyLoc = gl.getAttribLocation(bodyProg, 'a_position');
            gl.enableVertexAttribArray(dummyLoc);
            gl.vertexAttribPointer(dummyLoc, 2, gl.FLOAT, false, 0, 0);

            // 实例位置属性 (divisor = 1)
            gl.bindBuffer(gl.ARRAY_BUFFER, bodyPosBuffer);
            const instancePosLoc = gl.getAttribLocation(bodyProg, 'a_position');
            gl.enableVertexAttribArray(instancePosLoc);
            gl.vertexAttribPointer(instancePosLoc, 2, gl.FLOAT, false, 0, 0);
            gl.vertexAttribDivisor(instancePosLoc, 1);

            // 实例质量属性 (divisor = 1)
            gl.bindBuffer(gl.ARRAY_BUFFER, bodyMassBuffer);
            const massLoc = gl.getAttribLocation(bodyProg, 'a_mass');
            gl.enableVertexAttribArray(massLoc);
            gl.vertexAttribPointer(massLoc, 1, gl.FLOAT, false, 0, 0);
            gl.vertexAttribDivisor(massLoc, 1);

            // 实例类型属性 (divisor = 1)
            gl.bindBuffer(gl.ARRAY_BUFFER, bodyTypeBuffer);
            const typeLoc = gl.getAttribLocation(bodyProg, 'a_type');
            gl.enableVertexAttribArray(typeLoc);
            gl.vertexAttribPointer(typeLoc, 1, gl.FLOAT, false, 0, 0);
            gl.vertexAttribDivisor(typeLoc, 1);

            gl.drawArraysInstanced(gl.POINTS, 0, 1, count);

            // 重置 divisor（可选，防止影响后续绘制）
            gl.vertexAttribDivisor(instancePosLoc, 0);
            gl.vertexAttribDivisor(massLoc, 0);
            gl.vertexAttribDivisor(typeLoc, 0);
        }

        function drawWebGL() {
            gl.clear(gl.COLOR_BUFFER_BIT);
            drawGrid();
            drawDarkMatter();
            drawBodies();
        }

        // ==================== 初始化 & 动画循环 ====================
        const sensors = new SensorFusion();
        const universe = new Universe(L);

        document.getElementById('bindT').addEventListener('change', (e) => {
            const val = e.target.value;
            if (val === 'none') universe.bindings.T = null;
            else universe.setBinding('T', val, 0.1, 4.5, 0, 100);
        });
        document.getElementById('bindH').addEventListener('change', (e) => {
            const val = e.target.value;
            if (val === 'none') universe.bindings.H = null;
            else universe.setBinding('H', val, -2, 2, -20, 20);
        });
        document.getElementById('bindJ').addEventListener('change', (e) => {
            const val = e.target.value;
            if (val === 'none') universe.bindings.J = null;
            else universe.setBinding('J', val, 0.2, 2.0, 0, 100);
        });

        document.getElementById('resetBtn').addEventListener('click', () => universe.randomReset());
        let running = true;
        document.getElementById('pauseBtn').addEventListener('click', () => {
            running = !running;
            document.getElementById('pauseBtn').innerText = running ? '暂停' : '继续';
        });
        document.getElementById('addStarBtn').addEventListener('click', () => universe.addBody('star'));
        document.getElementById('addBlackHoleBtn').addEventListener('click', () => universe.addBody('blackhole'));
        document.getElementById('addPlanetBtn').addEventListener('click', () => universe.addBody('planet'));
        document.getElementById('addAsteroidBtn').addEventListener('click', () => universe.addBody('asteroid'));

        function updateStats() {
            document.getElementById('accMagnitude').innerText = sensors.accMagnitude.toFixed(1);
            document.getElementById('dmDensity').innerText = universe.dmDensityAvg();
            document.getElementById('bodyCount').innerText = universe.bodyCount();
            document.getElementById('bhMass').innerText = universe.bhMass();
        }
        setInterval(updateStats, 100);

        function animate() {
            if (running) {
                universe.updateParams(sensors);
                universe.step();
                drawWebGL();
            }
            requestAnimationFrame(animate);
        }
        animate();
    </script>
</body>
</html>
